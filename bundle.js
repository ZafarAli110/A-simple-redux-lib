(()=>{"use strict";eval("\n;// CONCATENATED MODULE: ./src_v3/redux/createStore.js\n// Original redux.js createStore ref: https://github.com/reduxjs/redux/blob/d6bad9a8be90defc71b27c33e1348a4f6133b852/src/createStore.js\nfunction createStore(reducer, preloadedState, middleware) {\n  let currentReducer = reducer;\n  let currentState = preloadedState; // initial state while creating the store.\n\n  let currentListners = [];\n  let nextListners = currentListners;\n\n  function getState() {\n    return currentState;\n  }\n\n  function dispatch(action) {\n    if (!action || typeof action !== 'object' || Array.isArray(action)) {\n      throw new Error('Action must be an object!');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Action must have a type!');\n    } // Reducer returns the new state\n\n\n    currentState = currentReducer(currentState, action); // Calling all the listeners/subscribers so that they can get the updated state\n\n    const listeners = currentListners = nextListners;\n\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  function subscribe(listener) {\n    nextListners.push(listener);\n  }\n\n  if (middleware) {\n    return {\n      getState,\n      dispatch: middleware({\n        dispatch,\n        getState\n      })(dispatch),\n      subscribe\n    };\n  } else {\n    return {\n      getState,\n      dispatch,\n      subscribe\n    };\n  }\n}\n;// CONCATENATED MODULE: ./src_v3/redux/utils/combineReducers.js\n/* \r\n  The combineReducers function call takes an object with reducers and returns a reducer \r\n  function, the returned function must have the signature of a reducer function (the state and an action).\r\n*/\n// Original reduxjs combineReducers ref: https://github.com/reduxjs/redux/blob/d6bad9a8be90defc71b27c33e1348a4f6133b852/src/combineReducers.js\nfunction combineReducers(reducers) {\n  // First get an array with all the keys of the reducers \n  const reducerKeys = Object.keys(reducers); // Returns a root reducer function, our createStore function will call this function\n  // with state and action whenever we dispatch an action via store.dispatch\n\n  return function combination(state = {}, action) {\n    const nextState = {}; // This is the final object we are going to return\n    // Loop through all the reducer keys\n\n    for (let i = 0; i < reducerKeys.length; i++) {\n      // Get the current key name\n      const reducerKey = reducerKeys[i]; // Get the current reducer function, \n      // remember we have passed the object with key and reducer fn as a value\n      // in our combineReducers call\n\n      const reducer = reducers[reducerKey]; // Get the the previous state of current reducer\n\n      const previousStateOfReducer = state[reducerKey]; // Get the next state by calling the current reducer function\n\n      const nextStateOfReducer = reducer(previousStateOfReducer, action); // Update the new state for the current reducer \n\n      nextState[reducerKey] = nextStateOfReducer;\n    }\n\n    return nextState;\n  };\n}\n;// CONCATENATED MODULE: ./src_v3/redux/actions/actionTypes.js\nconst INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\nconst ADD_TODO = 'ADD_TODO';\nconst UNDO = 'UNDO';\nconst REDO = 'REDO';\nconst GET_JOKE = 'GET_JOKE';\nconst GET_JOKE_SUCCESS = 'GET_JOKE_SUCCESS';\nconst GET_JOKE_FAILED = 'GET_JOKE_FAILED';\n;// CONCATENATED MODULE: ./src_v3/redux/reducers/counterReducer.js\n\nconst initialState = {\n  counter: 0\n};\nfunction reducer(state = initialState, action = {}) {\n  switch (action.type) {\n    case INCREMENT:\n      return { ...state,\n        counter: state.counter + 1\n      };\n\n    case DECREMENT:\n      return { ...state,\n        counter: state.counter - 1\n      };\n\n    default:\n      return state;\n  }\n}\n;// CONCATENATED MODULE: ./src_v3/redux/utils/undoableReducer.js\n // This implementation is copied from redux docs: https://redux.js.org/recipes/implementing-undo-history\n\nfunction undoable(reducer) {\n  const initialState = {\n    past: [],\n    present: reducer(undefined, {}),\n    // Call the reducer with undefined state and empty action to populate the initial state\n    future: []\n  }; // Return a reducer that handles undo and redo\n\n  return (state = initialState, action = {}) => {\n    const {\n      past,\n      present,\n      future\n    } = state;\n\n    switch (action.type) {\n      case UNDO:\n        {\n          const previous = past[past.length - 1];\n          const newPast = past.slice(0, past.length - 1);\n          const newFuture = [present, ...future];\n          return {\n            past: newPast,\n            present: previous,\n            future: newFuture\n          };\n        }\n\n      case REDO:\n        {\n          const next = future[0];\n          const newFuture = future.slice(1);\n          const newPast = [...past, present];\n          return {\n            past: newPast,\n            present: next,\n            future: newFuture\n          };\n        }\n\n      default:\n        {\n          // Delegate handling the action to the passed reducer\n          const newPresent = reducer(present, action);\n\n          if (newPresent === present) {\n            return state;\n          }\n\n          ;\n          return {\n            past: [...past, present],\n            present: newPresent,\n            future: []\n          };\n        }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src_v3/redux/reducers/todoReducer.js\n\n\nconst todoReducer_initialState = {\n  items: []\n};\n\nfunction todoReducer_reducer(state = todoReducer_initialState, action = {}) {\n  switch (action.type) {\n    case ADD_TODO:\n      return { ...state,\n        items: [...state.items, action.payload]\n      };\n\n    default:\n      return state;\n  }\n}\n\nconst undoableTodoReducer = undoable(todoReducer_reducer);\n/* harmony default export */ const todoReducer = (undoableTodoReducer);\n;// CONCATENATED MODULE: ./src_v3/redux/reducers/jokeReducer.js\n\nconst jokeReducer_initialState = {\n  loading: false,\n  data: {\n    setup: '',\n    punchline: ''\n  },\n  error: ''\n};\nfunction jokeReducer_reducer(state = jokeReducer_initialState, action = {}) {\n  switch (action.type) {\n    case GET_JOKE:\n      return { ...state,\n        loading: true,\n        error: ''\n      };\n\n    case GET_JOKE_SUCCESS:\n      return { ...state,\n        loading: false,\n        data: action.payload\n      };\n\n    case GET_JOKE_FAILED:\n      return { ...state,\n        loading: false,\n        error: action.payload\n      };\n\n    default:\n      return state;\n  }\n}\n;// CONCATENATED MODULE: ./src_v3/redux/reducers/rootReducer.js\n\n\n\n\n/* harmony default export */ const rootReducer = (combineReducers({\n  counter: reducer,\n  todos: todoReducer,\n  joke: jokeReducer_reducer\n}));\n;// CONCATENATED MODULE: ./utils.js\nconst log = color => {\n  return console.log.bind(console, '%c%s', `color: ${color};font-size:14px`);\n};\n\nconst group = (color, bgColor) => {\n  return console.group.bind(console, '%c%s', `color: ${color};background-color: ${bgColor} ;font-weight: bold ; padding: 4px ;`);\n};\n\nconst chalkLog = {\n  green: log('green'),\n  teal: log('teal'),\n  brown: log('brown'),\n  blue: log('blue'),\n  coral: log('coral'),\n  crimson: log('crimson'),\n  darkGray: log('darkGray')\n};\nconst chalkLogGroup = {\n  redish: group('#fff', '#e0005a'),\n  purple: group('#fff', '#9000e0'),\n  brownish: group('#fff', '#801b00d4'),\n  cadetBlue: group('#fff', 'cadetblue')\n};\n;// CONCATENATED MODULE: ./src_v3/redux/middlewares/logger.js\n\n\nconst loggerMiddleware = ({\n  getState\n}) => next => action => {\n  chalkLog.darkGray(\"<==========================================>\");\n  chalkLog.blue('before: appState -> ', JSON.stringify(getState(), null, 2));\n  chalkLog.blue('action -> ', action);\n  const returnedValue = next(action);\n  chalkLog.blue('after: appState -> ', JSON.stringify(getState(), null, 2));\n  return returnedValue;\n};\n\n/* harmony default export */ const logger = (loggerMiddleware);\n;// CONCATENATED MODULE: ./src_v3/redux/middlewares/thunk.js\n// Original thunkMiddleware ref:- https://github.com/reduxjs/redux-thunk/blob/master/src/index.js\nconst thunkMiddleware = ({\n  dispatch,\n  getState\n}) => next => action => {\n  if (typeof action === 'function') {\n    return action(dispatch, getState);\n  }\n\n  return next(action);\n};\n\n/* harmony default export */ const thunk = (thunkMiddleware);\n;// CONCATENATED MODULE: ./src_v3/redux/middlewares/index.js\n\n\n\n;// CONCATENATED MODULE: ./src_v3/redux/utils/applyMiddleware.js\n// Original redux.js applyMiddleware ref:- https://github.com/reduxjs/redux/blob/d6bad9a8be90defc71b27c33e1348a4f6133b852/src/applyMiddleware.js\nconst appyMiddleware = (...middlewares) => store => {\n  if (middlewares.length === 0) {\n    return dispatch => dispatch;\n  }\n\n  const middlewareAPI = {\n    getState: store.getState,\n    dispatch: (action, ...args) => dispatch(action, ...args)\n  };\n\n  if (middlewares.length === 1) {\n    return middlewares[0](middlewareAPI);\n  }\n\n  const boundMiddlewares = middlewares.map(middleware => middleware(middlewareAPI));\n  return boundMiddlewares.reduce((a, b) => next => a(b(next)));\n};\n;// CONCATENATED MODULE: ./src_v3/redux/actions/actionCreators.js\n\nconst increment = () => ({\n  type: INCREMENT\n});\nconst decrement = () => ({\n  type: DECREMENT\n});\nconst addTodo = payload => ({\n  type: ADD_TODO,\n  payload\n});\nconst undo = () => ({\n  type: UNDO\n});\nconst redo = () => ({\n  type: REDO\n});\nconst getJokeSuccess = payload => ({\n  type: GET_JOKE_SUCCESS,\n  payload\n});\nconst getJokeFailed = error => ({\n  type: GET_JOKE_FAILED,\n  payload: error\n});\nconst getJoke = dispatch => {\n  dispatch({\n    type: GET_JOKE\n  });\n  return fetch('https://official-joke-api.appspot.com/random_joke') // https://github.com/15Dkatz/official_joke_api\n  .then(res => res.json()).then(({\n    setup,\n    punchline\n  }) => {\n    const payload = {\n      setup,\n      punchline\n    };\n    dispatch(getJokeSuccess(payload));\n  }).catch(err => dispatch(getJokeFailed(err)));\n};\n;// CONCATENATED MODULE: ./src_v3/components/counter.component.js\n\nclass CounterComponent {\n  constructor(store) {\n    this.state = {\n      counter: 0\n    };\n    store.subscribe(() => {\n      // Subscribe/Connect to store\n      const state = store.getState();\n      this.setState({ ...state.counter\n      });\n    });\n    this.counterElementRef = document.getElementById('counter');\n    this.bindActions(store);\n  }\n\n  setState(newState) {\n    this.state = { ...this.state,\n      ...newState\n    };\n    this.render(); // Update the UI\n  }\n\n  bindActions(store) {\n    document.getElementById('btn-increment').addEventListener('click', () => {\n      store.dispatch(increment());\n    });\n    document.getElementById('btn-decrement').addEventListener('click', () => {\n      store.dispatch(decrement());\n    });\n  } // Render the UI\n\n\n  render() {\n    const {\n      counter\n    } = this.state;\n    this.counterElementRef.textContent = counter;\n  }\n\n}\n;// CONCATENATED MODULE: ./src_v3/components/todo.component.js\n\nclass TodoComponent {\n  constructor(store) {\n    this.state = {\n      past: [],\n      present: {\n        items: []\n      },\n      future: []\n    };\n    store.subscribe(() => {\n      // Subscribe/Connect to store\n      const state = store.getState();\n      this.setState({ ...state.todos\n      });\n    });\n    this.setElementRef();\n    this.bindActions(store);\n  }\n\n  setState(newState) {\n    this.state = { ...this.state,\n      ...newState\n    };\n    this.render(); // Update the UI\n  }\n\n  setElementRef() {\n    this.containerRef = document.getElementById('todo-container');\n    this.btnAddRef = document.getElementById('btn-add');\n    this.btnUndoRef = document.getElementById('btn-undo');\n    this.btnRedoRef = document.getElementById('btn-redo');\n    this.inputRef = document.getElementById('input');\n  }\n\n  bindActions(store) {\n    this.btnAddRef.addEventListener('click', () => {\n      const value = this.inputRef.value;\n\n      if (value) {\n        const payload = {\n          text: value\n        };\n        store.dispatch(addTodo(payload));\n      }\n\n      this.inputRef.value = '';\n    });\n    this.btnUndoRef.addEventListener('click', () => {\n      store.dispatch(undo());\n    });\n    this.btnRedoRef.addEventListener('click', () => {\n      store.dispatch(redo());\n    });\n  }\n\n  canUndoRedo() {\n    const {\n      past,\n      future\n    } = this.state;\n    past.length === 0 ? this.btnUndoRef.setAttribute('disabled', 'true') : this.btnUndoRef.removeAttribute('disabled');\n    future.length === 0 ? this.btnRedoRef.setAttribute('disabled', 'true') : this.btnRedoRef.removeAttribute('disabled');\n  }\n\n  renderList(items) {\n    this.canUndoRedo(); // check for list ref\n\n    const listRef = document.getElementById('todo-list');\n\n    if (items.length === 0) {\n      listRef && this.containerRef.removeChild(listRef); // remove old list from dom\n\n      return null;\n    } // create a ul element\n\n\n    const ulElement = document.createElement('ul');\n    ulElement.id = 'todo-list'; // loop through all the items and append the list item to ul element\n\n    items.forEach(item => {\n      const li = document.createElement('li');\n      li.textContent = item.text;\n      ulElement.appendChild(li);\n    }); // append the ul element to the container\n\n    listRef ? this.containerRef.replaceChild(ulElement, listRef) : this.containerRef.appendChild(ulElement);\n  } // Render the UI\n\n\n  render() {\n    const {\n      items\n    } = this.state.present;\n    this.renderList(items);\n  }\n\n}\n;// CONCATENATED MODULE: ./src_v3/components/joke.component.js\n\nclass JokeComponent {\n  constructor(store) {\n    this.state = {\n      loading: false,\n      data: {\n        setup: '',\n        punchline: ''\n      },\n      error: ''\n    };\n    store.subscribe(() => {\n      // Subscribe/Connect to store\n      const state = store.getState();\n      this.setState({ ...state.joke\n      });\n    });\n    this.jokeContainerRef = document.getElementById('joke-container');\n    this.bindAction(store);\n  }\n\n  setState(newState) {\n    this.state = { ...this.state,\n      ...newState\n    };\n    this.render(); // Update the UI\n  }\n\n  bindAction(store) {\n    document.getElementById('btn-getJoke').addEventListener('click', () => {\n      getJoke(store.dispatch);\n    });\n  } // Render the UI\n\n\n  render() {\n    const {\n      loading,\n      data,\n      error\n    } = this.state;\n\n    if (loading) {\n      return this.jokeContainerRef.textContent = 'Loading a joke please wait...';\n    } else if (error) {\n      return this.jokeContainerRef.textContent = `${error}, please try again.`;\n    }\n\n    const {\n      setup,\n      punchline\n    } = data;\n    const p1 = document.createElement('p');\n    p1.setAttribute('style', 'margin: 5px');\n    const p2 = document.createElement('p');\n    p2.setAttribute('style', 'margin: 5px');\n    p1.textContent = setup;\n    p2.textContent = punchline && `${punchline} \\uD83D\\uDE00`; // where \\uD83D\\uDE00 is a js emoji code \n\n    this.jokeContainerRef.textContent = '';\n    this.jokeContainerRef.appendChild(p1);\n    this.jokeContainerRef.appendChild(p2);\n  }\n\n}\n;// CONCATENATED MODULE: ./src_v3/app.js\n\n\n\n\n\n\n\nconst middlewares = [logger, thunk];\nconst store = createStore(rootReducer, {}, appyMiddleware(...middlewares));\n\nfunction loadApp() {\n  const counterComponent = new CounterComponent(store);\n  const todoComponent = new TodoComponent(store);\n  const jokeComponent = new JokeComponent(store);\n  counterComponent.render();\n  todoComponent.render();\n  jokeComponent.render();\n} // Bootstrap the application \n\n\nloadApp();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9yZWR1eC9jcmVhdGVTdG9yZS5qcz8xYmVhIiwid2VicGFjazovL3NpbXBsZS1yZWR1eC1saWIvLi9zcmNfdjMvcmVkdXgvdXRpbHMvY29tYmluZVJlZHVjZXJzLmpzPzkxYjYiLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9yZWR1eC9hY3Rpb25zL2FjdGlvblR5cGVzLmpzPzVkNmQiLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9yZWR1eC9yZWR1Y2Vycy9jb3VudGVyUmVkdWNlci5qcz9lZGNjIiwid2VicGFjazovL3NpbXBsZS1yZWR1eC1saWIvLi9zcmNfdjMvcmVkdXgvdXRpbHMvdW5kb2FibGVSZWR1Y2VyLmpzPzA3MDUiLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9yZWR1eC9yZWR1Y2Vycy90b2RvUmVkdWNlci5qcz8zZjZhIiwid2VicGFjazovL3NpbXBsZS1yZWR1eC1saWIvLi9zcmNfdjMvcmVkdXgvcmVkdWNlcnMvam9rZVJlZHVjZXIuanM/NzRjMSIsIndlYnBhY2s6Ly9zaW1wbGUtcmVkdXgtbGliLy4vc3JjX3YzL3JlZHV4L3JlZHVjZXJzL3Jvb3RSZWR1Y2VyLmpzP2RkMDQiLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3V0aWxzLmpzPzhiNjAiLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9yZWR1eC9taWRkbGV3YXJlcy9sb2dnZXIuanM/NWRiYyIsIndlYnBhY2s6Ly9zaW1wbGUtcmVkdXgtbGliLy4vc3JjX3YzL3JlZHV4L21pZGRsZXdhcmVzL3RodW5rLmpzPzA0ODkiLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9yZWR1eC9taWRkbGV3YXJlcy9pbmRleC5qcz8xYTQ3Iiwid2VicGFjazovL3NpbXBsZS1yZWR1eC1saWIvLi9zcmNfdjMvcmVkdXgvdXRpbHMvYXBwbHlNaWRkbGV3YXJlLmpzPzJkYTciLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9yZWR1eC9hY3Rpb25zL2FjdGlvbkNyZWF0b3JzLmpzPzA3OGEiLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9jb21wb25lbnRzL2NvdW50ZXIuY29tcG9uZW50LmpzP2U5MTIiLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9jb21wb25lbnRzL3RvZG8uY29tcG9uZW50LmpzP2IxYzQiLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9jb21wb25lbnRzL2pva2UuY29tcG9uZW50LmpzPzM2NzYiLCJ3ZWJwYWNrOi8vc2ltcGxlLXJlZHV4LWxpYi8uL3NyY192My9hcHAuanM/MTJkYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPcmlnaW5hbCByZWR1eC5qcyBjcmVhdGVTdG9yZSByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3JlZHV4L2Jsb2IvZDZiYWQ5YThiZTkwZGVmYzcxYjI3YzMzZTEzNDhhNGY2MTMzYjg1Mi9zcmMvY3JlYXRlU3RvcmUuanNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBtaWRkbGV3YXJlKSB7XG4gIGxldCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIGxldCBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTsgLy8gaW5pdGlhbCBzdGF0ZSB3aGlsZSBjcmVhdGluZyB0aGUgc3RvcmUuXG5cbiAgbGV0IGN1cnJlbnRMaXN0bmVycyA9IFtdO1xuICBsZXQgbmV4dExpc3RuZXJzID0gY3VycmVudExpc3RuZXJzO1xuXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWFjdGlvbiB8fCB0eXBlb2YgYWN0aW9uICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9uIG11c3QgYmUgYW4gb2JqZWN0IScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbiBtdXN0IGhhdmUgYSB0eXBlIScpO1xuICAgIH0gLy8gUmVkdWNlciByZXR1cm5zIHRoZSBuZXcgc3RhdGVcblxuXG4gICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pOyAvLyBDYWxsaW5nIGFsbCB0aGUgbGlzdGVuZXJzL3N1YnNjcmliZXJzIHNvIHRoYXQgdGhleSBjYW4gZ2V0IHRoZSB1cGRhdGVkIHN0YXRlXG5cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdG5lcnMgPSBuZXh0TGlzdG5lcnM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBuZXh0TGlzdG5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBpZiAobWlkZGxld2FyZSkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRTdGF0ZSxcbiAgICAgIGRpc3BhdGNoOiBtaWRkbGV3YXJlKHtcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIGdldFN0YXRlXG4gICAgICB9KShkaXNwYXRjaCksXG4gICAgICBzdWJzY3JpYmVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRTdGF0ZSxcbiAgICAgIGRpc3BhdGNoLFxuICAgICAgc3Vic2NyaWJlXG4gICAgfTtcbiAgfVxufSIsIi8qIFxyXG4gIFRoZSBjb21iaW5lUmVkdWNlcnMgZnVuY3Rpb24gY2FsbCB0YWtlcyBhbiBvYmplY3Qgd2l0aCByZWR1Y2VycyBhbmQgcmV0dXJucyBhIHJlZHVjZXIgXHJcbiAgZnVuY3Rpb24sIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBtdXN0IGhhdmUgdGhlIHNpZ25hdHVyZSBvZiBhIHJlZHVjZXIgZnVuY3Rpb24gKHRoZSBzdGF0ZSBhbmQgYW4gYWN0aW9uKS5cclxuKi9cbi8vIE9yaWdpbmFsIHJlZHV4anMgY29tYmluZVJlZHVjZXJzIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL3JlZHV4anMvcmVkdXgvYmxvYi9kNmJhZDlhOGJlOTBkZWZjNzFiMjdjMzNlMTM0OGE0ZjYxMzNiODUyL3NyYy9jb21iaW5lUmVkdWNlcnMuanNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICAvLyBGaXJzdCBnZXQgYW4gYXJyYXkgd2l0aCBhbGwgdGhlIGtleXMgb2YgdGhlIHJlZHVjZXJzIFxuICBjb25zdCByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTsgLy8gUmV0dXJucyBhIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgb3VyIGNyZWF0ZVN0b3JlIGZ1bmN0aW9uIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uXG4gIC8vIHdpdGggc3RhdGUgYW5kIGFjdGlvbiB3aGVuZXZlciB3ZSBkaXNwYXRjaCBhbiBhY3Rpb24gdmlhIHN0b3JlLmRpc3BhdGNoXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKHN0YXRlID0ge30sIGFjdGlvbikge1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHt9OyAvLyBUaGlzIGlzIHRoZSBmaW5hbCBvYmplY3Qgd2UgYXJlIGdvaW5nIHRvIHJldHVyblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHJlZHVjZXIga2V5c1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGtleSBuYW1lXG4gICAgICBjb25zdCByZWR1Y2VyS2V5ID0gcmVkdWNlcktleXNbaV07IC8vIEdldCB0aGUgY3VycmVudCByZWR1Y2VyIGZ1bmN0aW9uLCBcbiAgICAgIC8vIHJlbWVtYmVyIHdlIGhhdmUgcGFzc2VkIHRoZSBvYmplY3Qgd2l0aCBrZXkgYW5kIHJlZHVjZXIgZm4gYXMgYSB2YWx1ZVxuICAgICAgLy8gaW4gb3VyIGNvbWJpbmVSZWR1Y2VycyBjYWxsXG5cbiAgICAgIGNvbnN0IHJlZHVjZXIgPSByZWR1Y2Vyc1tyZWR1Y2VyS2V5XTsgLy8gR2V0IHRoZSB0aGUgcHJldmlvdXMgc3RhdGUgb2YgY3VycmVudCByZWR1Y2VyXG5cbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGVPZlJlZHVjZXIgPSBzdGF0ZVtyZWR1Y2VyS2V5XTsgLy8gR2V0IHRoZSBuZXh0IHN0YXRlIGJ5IGNhbGxpbmcgdGhlIGN1cnJlbnQgcmVkdWNlciBmdW5jdGlvblxuXG4gICAgICBjb25zdCBuZXh0U3RhdGVPZlJlZHVjZXIgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVPZlJlZHVjZXIsIGFjdGlvbik7IC8vIFVwZGF0ZSB0aGUgbmV3IHN0YXRlIGZvciB0aGUgY3VycmVudCByZWR1Y2VyIFxuXG4gICAgICBuZXh0U3RhdGVbcmVkdWNlcktleV0gPSBuZXh0U3RhdGVPZlJlZHVjZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfTtcbn0iLCJleHBvcnQgY29uc3QgSU5DUkVNRU5UID0gJ0lOQ1JFTUVOVCc7XG5leHBvcnQgY29uc3QgREVDUkVNRU5UID0gJ0RFQ1JFTUVOVCc7XG5leHBvcnQgY29uc3QgQUREX1RPRE8gPSAnQUREX1RPRE8nO1xuZXhwb3J0IGNvbnN0IFVORE8gPSAnVU5ETyc7XG5leHBvcnQgY29uc3QgUkVETyA9ICdSRURPJztcbmV4cG9ydCBjb25zdCBHRVRfSk9LRSA9ICdHRVRfSk9LRSc7XG5leHBvcnQgY29uc3QgR0VUX0pPS0VfU1VDQ0VTUyA9ICdHRVRfSk9LRV9TVUNDRVNTJztcbmV4cG9ydCBjb25zdCBHRVRfSk9LRV9GQUlMRUQgPSAnR0VUX0pPS0VfRkFJTEVEJzsiLCJpbXBvcnQgeyBERUNSRU1FTlQsIElOQ1JFTUVOVCB9IGZyb20gXCIuLi9hY3Rpb25zL2FjdGlvblR5cGVzXCI7XG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGNvdW50ZXI6IDBcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlID0gaW5pdGlhbFN0YXRlLCBhY3Rpb24gPSB7fSkge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBJTkNSRU1FTlQ6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgY291bnRlcjogc3RhdGUuY291bnRlciArIDFcbiAgICAgIH07XG5cbiAgICBjYXNlIERFQ1JFTUVOVDpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICBjb3VudGVyOiBzdGF0ZS5jb3VudGVyIC0gMVxuICAgICAgfTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn0iLCJpbXBvcnQgeyBVTkRPLCBSRURPIH0gZnJvbSBcIi4uL2FjdGlvbnMvYWN0aW9uVHlwZXNcIjsgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBjb3BpZWQgZnJvbSByZWR1eCBkb2NzOiBodHRwczovL3JlZHV4LmpzLm9yZy9yZWNpcGVzL2ltcGxlbWVudGluZy11bmRvLWhpc3RvcnlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdW5kb2FibGUocmVkdWNlcikge1xuICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgcGFzdDogW10sXG4gICAgcHJlc2VudDogcmVkdWNlcih1bmRlZmluZWQsIHt9KSxcbiAgICAvLyBDYWxsIHRoZSByZWR1Y2VyIHdpdGggdW5kZWZpbmVkIHN0YXRlIGFuZCBlbXB0eSBhY3Rpb24gdG8gcG9wdWxhdGUgdGhlIGluaXRpYWwgc3RhdGVcbiAgICBmdXR1cmU6IFtdXG4gIH07IC8vIFJldHVybiBhIHJlZHVjZXIgdGhhdCBoYW5kbGVzIHVuZG8gYW5kIHJlZG9cblxuICByZXR1cm4gKHN0YXRlID0gaW5pdGlhbFN0YXRlLCBhY3Rpb24gPSB7fSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhc3QsXG4gICAgICBwcmVzZW50LFxuICAgICAgZnV0dXJlXG4gICAgfSA9IHN0YXRlO1xuXG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSBVTkRPOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBwYXN0W3Bhc3QubGVuZ3RoIC0gMV07XG4gICAgICAgICAgY29uc3QgbmV3UGFzdCA9IHBhc3Quc2xpY2UoMCwgcGFzdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBjb25zdCBuZXdGdXR1cmUgPSBbcHJlc2VudCwgLi4uZnV0dXJlXTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFzdDogbmV3UGFzdCxcbiAgICAgICAgICAgIHByZXNlbnQ6IHByZXZpb3VzLFxuICAgICAgICAgICAgZnV0dXJlOiBuZXdGdXR1cmVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVETzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBmdXR1cmVbMF07XG4gICAgICAgICAgY29uc3QgbmV3RnV0dXJlID0gZnV0dXJlLnNsaWNlKDEpO1xuICAgICAgICAgIGNvbnN0IG5ld1Bhc3QgPSBbLi4ucGFzdCwgcHJlc2VudF07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhc3Q6IG5ld1Bhc3QsXG4gICAgICAgICAgICBwcmVzZW50OiBuZXh0LFxuICAgICAgICAgICAgZnV0dXJlOiBuZXdGdXR1cmVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgYWN0aW9uIHRvIHRoZSBwYXNzZWQgcmVkdWNlclxuICAgICAgICAgIGNvbnN0IG5ld1ByZXNlbnQgPSByZWR1Y2VyKHByZXNlbnQsIGFjdGlvbik7XG5cbiAgICAgICAgICBpZiAobmV3UHJlc2VudCA9PT0gcHJlc2VudCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFzdDogWy4uLnBhc3QsIHByZXNlbnRdLFxuICAgICAgICAgICAgcHJlc2VudDogbmV3UHJlc2VudCxcbiAgICAgICAgICAgIGZ1dHVyZTogW11cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICB9O1xufSIsImltcG9ydCB7IEFERF9UT0RPIH0gZnJvbSBcIi4uL2FjdGlvbnMvYWN0aW9uVHlwZXNcIjtcbmltcG9ydCB1bmRvYWJsZSBmcm9tIFwiLi4vdXRpbHMvdW5kb2FibGVSZWR1Y2VyXCI7XG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGl0ZW1zOiBbXVxufTtcblxuZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uID0ge30pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgQUREX1RPRE86XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgaXRlbXM6IFsuLi5zdGF0ZS5pdGVtcywgYWN0aW9uLnBheWxvYWRdXG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCB1bmRvYWJsZVRvZG9SZWR1Y2VyID0gdW5kb2FibGUocmVkdWNlcik7XG5leHBvcnQgZGVmYXVsdCB1bmRvYWJsZVRvZG9SZWR1Y2VyOyIsImltcG9ydCB7IEdFVF9KT0tFLCBHRVRfSk9LRV9GQUlMRUQsIEdFVF9KT0tFX1NVQ0NFU1MgfSBmcm9tIFwiLi4vYWN0aW9ucy9hY3Rpb25UeXBlc1wiO1xuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBsb2FkaW5nOiBmYWxzZSxcbiAgZGF0YToge1xuICAgIHNldHVwOiAnJyxcbiAgICBwdW5jaGxpbmU6ICcnXG4gIH0sXG4gIGVycm9yOiAnJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUgPSBpbml0aWFsU3RhdGUsIGFjdGlvbiA9IHt9KSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIEdFVF9KT0tFOlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgIGVycm9yOiAnJ1xuICAgICAgfTtcblxuICAgIGNhc2UgR0VUX0pPS0VfU1VDQ0VTUzpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZGF0YTogYWN0aW9uLnBheWxvYWRcbiAgICAgIH07XG5cbiAgICBjYXNlIEdFVF9KT0tFX0ZBSUxFRDpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGFjdGlvbi5wYXlsb2FkXG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufSIsImltcG9ydCBjb21iaW5lUmVkdWNlcnMgZnJvbSAnLi4vdXRpbHMvY29tYmluZVJlZHVjZXJzJztcbmltcG9ydCBjb3VudGVyUmVkdWNlciBmcm9tICcuL2NvdW50ZXJSZWR1Y2VyJztcbmltcG9ydCB0b2RvUmVkdWNlciBmcm9tICcuL3RvZG9SZWR1Y2VyJztcbmltcG9ydCBqb2tlUmVkdWNlciBmcm9tICcuL2pva2VSZWR1Y2VyJztcbmV4cG9ydCBkZWZhdWx0IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGNvdW50ZXI6IGNvdW50ZXJSZWR1Y2VyLFxuICB0b2RvczogdG9kb1JlZHVjZXIsXG4gIGpva2U6IGpva2VSZWR1Y2VyXG59KTsiLCJjb25zdCBsb2cgPSBjb2xvciA9PiB7XG4gIHJldHVybiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUsICclYyVzJywgYGNvbG9yOiAke2NvbG9yfTtmb250LXNpemU6MTRweGApO1xufTtcblxuY29uc3QgZ3JvdXAgPSAoY29sb3IsIGJnQ29sb3IpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUuZ3JvdXAuYmluZChjb25zb2xlLCAnJWMlcycsIGBjb2xvcjogJHtjb2xvcn07YmFja2dyb3VuZC1jb2xvcjogJHtiZ0NvbG9yfSA7Zm9udC13ZWlnaHQ6IGJvbGQgOyBwYWRkaW5nOiA0cHggO2ApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNoYWxrTG9nID0ge1xuICBncmVlbjogbG9nKCdncmVlbicpLFxuICB0ZWFsOiBsb2coJ3RlYWwnKSxcbiAgYnJvd246IGxvZygnYnJvd24nKSxcbiAgYmx1ZTogbG9nKCdibHVlJyksXG4gIGNvcmFsOiBsb2coJ2NvcmFsJyksXG4gIGNyaW1zb246IGxvZygnY3JpbXNvbicpLFxuICBkYXJrR3JheTogbG9nKCdkYXJrR3JheScpXG59O1xuZXhwb3J0IGNvbnN0IGNoYWxrTG9nR3JvdXAgPSB7XG4gIHJlZGlzaDogZ3JvdXAoJyNmZmYnLCAnI2UwMDA1YScpLFxuICBwdXJwbGU6IGdyb3VwKCcjZmZmJywgJyM5MDAwZTAnKSxcbiAgYnJvd25pc2g6IGdyb3VwKCcjZmZmJywgJyM4MDFiMDBkNCcpLFxuICBjYWRldEJsdWU6IGdyb3VwKCcjZmZmJywgJ2NhZGV0Ymx1ZScpXG59OyIsImltcG9ydCB7IGNoYWxrTG9nIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMuanMnO1xuXG5jb25zdCBsb2dnZXJNaWRkbGV3YXJlID0gKHtcbiAgZ2V0U3RhdGVcbn0pID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgY2hhbGtMb2cuZGFya0dyYXkoXCI8PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PlwiKTtcbiAgY2hhbGtMb2cuYmx1ZSgnYmVmb3JlOiBhcHBTdGF0ZSAtPiAnLCBKU09OLnN0cmluZ2lmeShnZXRTdGF0ZSgpLCBudWxsLCAyKSk7XG4gIGNoYWxrTG9nLmJsdWUoJ2FjdGlvbiAtPiAnLCBhY3Rpb24pO1xuICBjb25zdCByZXR1cm5lZFZhbHVlID0gbmV4dChhY3Rpb24pO1xuICBjaGFsa0xvZy5ibHVlKCdhZnRlcjogYXBwU3RhdGUgLT4gJywgSlNPTi5zdHJpbmdpZnkoZ2V0U3RhdGUoKSwgbnVsbCwgMikpO1xuICByZXR1cm4gcmV0dXJuZWRWYWx1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxvZ2dlck1pZGRsZXdhcmU7IiwiLy8gT3JpZ2luYWwgdGh1bmtNaWRkbGV3YXJlIHJlZjotIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3JlZHV4LXRodW5rL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xuY29uc3QgdGh1bmtNaWRkbGV3YXJlID0gKHtcbiAgZGlzcGF0Y2gsXG4gIGdldFN0YXRlXG59KSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGFjdGlvbihkaXNwYXRjaCwgZ2V0U3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHRodW5rTWlkZGxld2FyZTsiLCJpbXBvcnQgbG9nZ2luZ01pZGRsZXdhcmUgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHRodW5rTWlkZGxld2FyZSBmcm9tICcuL3RodW5rJztcbmV4cG9ydCB7IGxvZ2dpbmdNaWRkbGV3YXJlLCB0aHVua01pZGRsZXdhcmUgfTsiLCIvLyBPcmlnaW5hbCByZWR1eC5qcyBhcHBseU1pZGRsZXdhcmUgcmVmOi0gaHR0cHM6Ly9naXRodWIuY29tL3JlZHV4anMvcmVkdXgvYmxvYi9kNmJhZDlhOGJlOTBkZWZjNzFiMjdjMzNlMTM0OGE0ZjYxMzNiODUyL3NyYy9hcHBseU1pZGRsZXdhcmUuanNcbmV4cG9ydCBjb25zdCBhcHB5TWlkZGxld2FyZSA9ICguLi5taWRkbGV3YXJlcykgPT4gc3RvcmUgPT4ge1xuICBpZiAobWlkZGxld2FyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoID0+IGRpc3BhdGNoO1xuICB9XG5cbiAgY29uc3QgbWlkZGxld2FyZUFQSSA9IHtcbiAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgZGlzcGF0Y2g6IChhY3Rpb24sIC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFjdGlvbiwgLi4uYXJncylcbiAgfTtcblxuICBpZiAobWlkZGxld2FyZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmVzWzBdKG1pZGRsZXdhcmVBUEkpO1xuICB9XG5cbiAgY29uc3QgYm91bmRNaWRkbGV3YXJlcyA9IG1pZGRsZXdhcmVzLm1hcChtaWRkbGV3YXJlID0+IG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSkpO1xuICByZXR1cm4gYm91bmRNaWRkbGV3YXJlcy5yZWR1Y2UoKGEsIGIpID0+IG5leHQgPT4gYShiKG5leHQpKSk7XG59OyIsImltcG9ydCB7IERFQ1JFTUVOVCwgSU5DUkVNRU5ULCBBRERfVE9ETywgVU5ETywgUkVETywgR0VUX0pPS0UsIEdFVF9KT0tFX1NVQ0NFU1MsIEdFVF9KT0tFX0ZBSUxFRCB9IGZyb20gXCIuL2FjdGlvblR5cGVzXCI7XG5leHBvcnQgY29uc3QgaW5jcmVtZW50ID0gKCkgPT4gKHtcbiAgdHlwZTogSU5DUkVNRU5UXG59KTtcbmV4cG9ydCBjb25zdCBkZWNyZW1lbnQgPSAoKSA9PiAoe1xuICB0eXBlOiBERUNSRU1FTlRcbn0pO1xuZXhwb3J0IGNvbnN0IGFkZFRvZG8gPSBwYXlsb2FkID0+ICh7XG4gIHR5cGU6IEFERF9UT0RPLFxuICBwYXlsb2FkXG59KTtcbmV4cG9ydCBjb25zdCB1bmRvID0gKCkgPT4gKHtcbiAgdHlwZTogVU5ET1xufSk7XG5leHBvcnQgY29uc3QgcmVkbyA9ICgpID0+ICh7XG4gIHR5cGU6IFJFRE9cbn0pO1xuZXhwb3J0IGNvbnN0IGdldEpva2VTdWNjZXNzID0gcGF5bG9hZCA9PiAoe1xuICB0eXBlOiBHRVRfSk9LRV9TVUNDRVNTLFxuICBwYXlsb2FkXG59KTtcbmV4cG9ydCBjb25zdCBnZXRKb2tlRmFpbGVkID0gZXJyb3IgPT4gKHtcbiAgdHlwZTogR0VUX0pPS0VfRkFJTEVELFxuICBwYXlsb2FkOiBlcnJvclxufSk7XG5leHBvcnQgY29uc3QgZ2V0Sm9rZSA9IGRpc3BhdGNoID0+IHtcbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6IEdFVF9KT0tFXG4gIH0pO1xuICByZXR1cm4gZmV0Y2goJ2h0dHBzOi8vb2ZmaWNpYWwtam9rZS1hcGkuYXBwc3BvdC5jb20vcmFuZG9tX2pva2UnKSAvLyBodHRwczovL2dpdGh1Yi5jb20vMTVEa2F0ei9vZmZpY2lhbF9qb2tlX2FwaVxuICAudGhlbihyZXMgPT4gcmVzLmpzb24oKSkudGhlbigoe1xuICAgIHNldHVwLFxuICAgIHB1bmNobGluZVxuICB9KSA9PiB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHNldHVwLFxuICAgICAgcHVuY2hsaW5lXG4gICAgfTtcbiAgICBkaXNwYXRjaChnZXRKb2tlU3VjY2VzcyhwYXlsb2FkKSk7XG4gIH0pLmNhdGNoKGVyciA9PiBkaXNwYXRjaChnZXRKb2tlRmFpbGVkKGVycikpKTtcbn07IiwiaW1wb3J0IHsgaW5jcmVtZW50LCBkZWNyZW1lbnQgfSBmcm9tIFwiLi4vcmVkdXgvYWN0aW9ucy9hY3Rpb25DcmVhdG9yc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ291bnRlckNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHN0b3JlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNvdW50ZXI6IDBcbiAgICB9O1xuICAgIHN0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyBTdWJzY3JpYmUvQ29ubmVjdCB0byBzdG9yZVxuICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IC4uLnN0YXRlLmNvdW50ZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuY291bnRlckVsZW1lbnRSZWYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY291bnRlcicpO1xuICAgIHRoaXMuYmluZEFjdGlvbnMoc3RvcmUpO1xuICB9XG5cbiAgc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlID0geyAuLi50aGlzLnN0YXRlLFxuICAgICAgLi4ubmV3U3RhdGVcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyKCk7IC8vIFVwZGF0ZSB0aGUgVUlcbiAgfVxuXG4gIGJpbmRBY3Rpb25zKHN0b3JlKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bi1pbmNyZW1lbnQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGluY3JlbWVudCgpKTtcbiAgICB9KTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLWRlY3JlbWVudCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZGVjcmVtZW50KCkpO1xuICAgIH0pO1xuICB9IC8vIFJlbmRlciB0aGUgVUlcblxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb3VudGVyXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5jb3VudGVyRWxlbWVudFJlZi50ZXh0Q29udGVudCA9IGNvdW50ZXI7XG4gIH1cblxufSIsImltcG9ydCB7IGFkZFRvZG8sIHJlZG8sIHVuZG8gfSBmcm9tIFwiLi4vcmVkdXgvYWN0aW9ucy9hY3Rpb25DcmVhdG9yc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9kb0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHN0b3JlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHBhc3Q6IFtdLFxuICAgICAgcHJlc2VudDoge1xuICAgICAgICBpdGVtczogW11cbiAgICAgIH0sXG4gICAgICBmdXR1cmU6IFtdXG4gICAgfTtcbiAgICBzdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgLy8gU3Vic2NyaWJlL0Nvbm5lY3QgdG8gc3RvcmVcbiAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyAuLi5zdGF0ZS50b2Rvc1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZXRFbGVtZW50UmVmKCk7XG4gICAgdGhpcy5iaW5kQWN0aW9ucyhzdG9yZSk7XG4gIH1cblxuICBzZXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSB7IC4uLnRoaXMuc3RhdGUsXG4gICAgICAuLi5uZXdTdGF0ZVxuICAgIH07XG4gICAgdGhpcy5yZW5kZXIoKTsgLy8gVXBkYXRlIHRoZSBVSVxuICB9XG5cbiAgc2V0RWxlbWVudFJlZigpIHtcbiAgICB0aGlzLmNvbnRhaW5lclJlZiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b2RvLWNvbnRhaW5lcicpO1xuICAgIHRoaXMuYnRuQWRkUmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bi1hZGQnKTtcbiAgICB0aGlzLmJ0blVuZG9SZWYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLXVuZG8nKTtcbiAgICB0aGlzLmJ0blJlZG9SZWYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLXJlZG8nKTtcbiAgICB0aGlzLmlucHV0UmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0Jyk7XG4gIH1cblxuICBiaW5kQWN0aW9ucyhzdG9yZSkge1xuICAgIHRoaXMuYnRuQWRkUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0UmVmLnZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICB0ZXh0OiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBzdG9yZS5kaXNwYXRjaChhZGRUb2RvKHBheWxvYWQpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnB1dFJlZi52YWx1ZSA9ICcnO1xuICAgIH0pO1xuICAgIHRoaXMuYnRuVW5kb1JlZi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKHVuZG8oKSk7XG4gICAgfSk7XG4gICAgdGhpcy5idG5SZWRvUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgc3RvcmUuZGlzcGF0Y2gocmVkbygpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNhblVuZG9SZWRvKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhc3QsXG4gICAgICBmdXR1cmVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBwYXN0Lmxlbmd0aCA9PT0gMCA/IHRoaXMuYnRuVW5kb1JlZi5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKSA6IHRoaXMuYnRuVW5kb1JlZi5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgZnV0dXJlLmxlbmd0aCA9PT0gMCA/IHRoaXMuYnRuUmVkb1JlZi5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKSA6IHRoaXMuYnRuUmVkb1JlZi5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICByZW5kZXJMaXN0KGl0ZW1zKSB7XG4gICAgdGhpcy5jYW5VbmRvUmVkbygpOyAvLyBjaGVjayBmb3IgbGlzdCByZWZcblxuICAgIGNvbnN0IGxpc3RSZWYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG9kby1saXN0Jyk7XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsaXN0UmVmICYmIHRoaXMuY29udGFpbmVyUmVmLnJlbW92ZUNoaWxkKGxpc3RSZWYpOyAvLyByZW1vdmUgb2xkIGxpc3QgZnJvbSBkb21cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBjcmVhdGUgYSB1bCBlbGVtZW50XG5cblxuICAgIGNvbnN0IHVsRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgdWxFbGVtZW50LmlkID0gJ3RvZG8tbGlzdCc7IC8vIGxvb3AgdGhyb3VnaCBhbGwgdGhlIGl0ZW1zIGFuZCBhcHBlbmQgdGhlIGxpc3QgaXRlbSB0byB1bCBlbGVtZW50XG5cbiAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgbGkudGV4dENvbnRlbnQgPSBpdGVtLnRleHQ7XG4gICAgICB1bEVsZW1lbnQuYXBwZW5kQ2hpbGQobGkpO1xuICAgIH0pOyAvLyBhcHBlbmQgdGhlIHVsIGVsZW1lbnQgdG8gdGhlIGNvbnRhaW5lclxuXG4gICAgbGlzdFJlZiA/IHRoaXMuY29udGFpbmVyUmVmLnJlcGxhY2VDaGlsZCh1bEVsZW1lbnQsIGxpc3RSZWYpIDogdGhpcy5jb250YWluZXJSZWYuYXBwZW5kQ2hpbGQodWxFbGVtZW50KTtcbiAgfSAvLyBSZW5kZXIgdGhlIFVJXG5cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXRlbXNcbiAgICB9ID0gdGhpcy5zdGF0ZS5wcmVzZW50O1xuICAgIHRoaXMucmVuZGVyTGlzdChpdGVtcyk7XG4gIH1cblxufSIsImltcG9ydCB7IGdldEpva2UgfSBmcm9tIFwiLi4vcmVkdXgvYWN0aW9ucy9hY3Rpb25DcmVhdG9yc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSm9rZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHN0b3JlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgZGF0YToge1xuICAgICAgICBzZXR1cDogJycsXG4gICAgICAgIHB1bmNobGluZTogJydcbiAgICAgIH0sXG4gICAgICBlcnJvcjogJydcbiAgICB9O1xuICAgIHN0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyBTdWJzY3JpYmUvQ29ubmVjdCB0byBzdG9yZVxuICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IC4uLnN0YXRlLmpva2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuam9rZUNvbnRhaW5lclJlZiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdqb2tlLWNvbnRhaW5lcicpO1xuICAgIHRoaXMuYmluZEFjdGlvbihzdG9yZSk7XG4gIH1cblxuICBzZXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSB7IC4uLnRoaXMuc3RhdGUsXG4gICAgICAuLi5uZXdTdGF0ZVxuICAgIH07XG4gICAgdGhpcy5yZW5kZXIoKTsgLy8gVXBkYXRlIHRoZSBVSVxuICB9XG5cbiAgYmluZEFjdGlvbihzdG9yZSkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG4tZ2V0Sm9rZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgZ2V0Sm9rZShzdG9yZS5kaXNwYXRjaCk7XG4gICAgfSk7XG4gIH0gLy8gUmVuZGVyIHRoZSBVSVxuXG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxvYWRpbmcsXG4gICAgICBkYXRhLFxuICAgICAgZXJyb3JcbiAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5qb2tlQ29udGFpbmVyUmVmLnRleHRDb250ZW50ID0gJ0xvYWRpbmcgYSBqb2tlIHBsZWFzZSB3YWl0Li4uJztcbiAgICB9IGVsc2UgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5qb2tlQ29udGFpbmVyUmVmLnRleHRDb250ZW50ID0gYCR7ZXJyb3J9LCBwbGVhc2UgdHJ5IGFnYWluLmA7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgc2V0dXAsXG4gICAgICBwdW5jaGxpbmVcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBwMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBwMS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ21hcmdpbjogNXB4Jyk7XG4gICAgY29uc3QgcDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgcDIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdtYXJnaW46IDVweCcpO1xuICAgIHAxLnRleHRDb250ZW50ID0gc2V0dXA7XG4gICAgcDIudGV4dENvbnRlbnQgPSBwdW5jaGxpbmUgJiYgYCR7cHVuY2hsaW5lfSBcXHVEODNEXFx1REUwMGA7IC8vIHdoZXJlIFxcdUQ4M0RcXHVERTAwIGlzIGEganMgZW1vamkgY29kZSBcblxuICAgIHRoaXMuam9rZUNvbnRhaW5lclJlZi50ZXh0Q29udGVudCA9ICcnO1xuICAgIHRoaXMuam9rZUNvbnRhaW5lclJlZi5hcHBlbmRDaGlsZChwMSk7XG4gICAgdGhpcy5qb2tlQ29udGFpbmVyUmVmLmFwcGVuZENoaWxkKHAyKTtcbiAgfVxuXG59IiwiaW1wb3J0IGNyZWF0ZVN0b3JlIGZyb20gXCIuL3JlZHV4L2NyZWF0ZVN0b3JlXCI7XG5pbXBvcnQgcm9vdFJlZHVjZXIgZnJvbSBcIi4vcmVkdXgvcmVkdWNlcnMvcm9vdFJlZHVjZXJcIjtcbmltcG9ydCB7IGxvZ2dpbmdNaWRkbGV3YXJlLCB0aHVua01pZGRsZXdhcmUgfSBmcm9tIFwiLi9yZWR1eC9taWRkbGV3YXJlc1wiO1xuaW1wb3J0IHsgYXBweU1pZGRsZXdhcmUgfSBmcm9tIFwiLi9yZWR1eC91dGlscy9hcHBseU1pZGRsZXdhcmVcIjtcbmltcG9ydCBDb3VudGVyQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudHMvY291bnRlci5jb21wb25lbnRcIjtcbmltcG9ydCBUb2RvQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudHMvdG9kby5jb21wb25lbnRcIjtcbmltcG9ydCBKb2tlQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudHMvam9rZS5jb21wb25lbnRcIjtcbmNvbnN0IG1pZGRsZXdhcmVzID0gW2xvZ2dpbmdNaWRkbGV3YXJlLCB0aHVua01pZGRsZXdhcmVdO1xuY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShyb290UmVkdWNlciwge30sIGFwcHlNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKSk7XG5cbmZ1bmN0aW9uIGxvYWRBcHAoKSB7XG4gIGNvbnN0IGNvdW50ZXJDb21wb25lbnQgPSBuZXcgQ291bnRlckNvbXBvbmVudChzdG9yZSk7XG4gIGNvbnN0IHRvZG9Db21wb25lbnQgPSBuZXcgVG9kb0NvbXBvbmVudChzdG9yZSk7XG4gIGNvbnN0IGpva2VDb21wb25lbnQgPSBuZXcgSm9rZUNvbXBvbmVudChzdG9yZSk7XG4gIGNvdW50ZXJDb21wb25lbnQucmVuZGVyKCk7XG4gIHRvZG9Db21wb25lbnQucmVuZGVyKCk7XG4gIGpva2VDb21wb25lbnQucmVuZGVyKCk7XG59IC8vIEJvb3RzdHJhcCB0aGUgYXBwbGljYXRpb24gXG5cblxubG9hZEFwcCgpOyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///359\n")})();